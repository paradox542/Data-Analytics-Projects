---
title: "Lending Club Part A"
author: "Li Lin, Saurav Anand, Abhishek Biswas"
date: "Sept 25, 2021"
output:
  pdf_document: 
    toc: yes
    fig_caption: yes
    number_sections: yes
  html_notebook: default
  html_document:
    df_print: paged
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 
# Library 

```{r}
library(tidyverse)
library(lubridate)
library(ggplot2)
library(dplyr,warn.conflicts = FALSE)
options(dplyr.summarise.inform = FALSE)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.



# The lcData100K.csv file contains a sample of data on 3-year loans  which we will use for this analyses
```{r}
lcdf <- read_csv('lcData100K.csv')
```

# Explore the data

Examine actual returns from a loan, and relation with int_rate
(for example, can one expect a 5%/year return from a loan with 5% int_rate?)
```{r}
#do loans return an amount as may be expected from the int_rate ? 
lcdf %>% select(loan_status, int_rate, funded_amnt, total_pymnt)
```
# Q2: a.i + a.ii
```{r}
#How does loan status vary by loan grade
lcdf %>% group_by(loan_status, grade) %>% tally()
#or, using table
table(lcdf$loan_status, lcdf$grade)
#   Do you have loans with status other than "Fully Paid" or "Charged Off"?  
#    If so, you should filter these out. For example, if there are some loans with status of "current", 
#       you can filter these out by lcdf <- lcdf %>%  filter(loan_status !="Current")


#How does number of loans, loan amount, interest rate vary by grade
lcdf %>% group_by(grade) %>% tally()
lcdf %>% group_by(grade) %>% summarise(sum(loan_amnt))   #and/or what is the mean loan_amnt by grade?
lcdf %>% group_by(grade) %>% summarise(mean(int_rate))

#Or plot these..
ggplot(lcdf, aes( x = int_rate)) + geom_histogram()
ggplot(lcdf, aes( x = loan_amnt)) + geom_histogram(aes(fill=grade))
ggplot(lcdf, aes( x = loan_amnt)) + geom_histogram(aes(fill=sub_grade))
ggplot(lcdf, aes( x = loan_amnt)) + geom_histogram() + facet_wrap(~loan_status)




lcdf %>% group_by(grade) %>% summarise(nLoans=n(), AverageInterestRate= mean(int_rate), SDInterest=sd(int_rate), AverageLoanAmount=mean(loan_amnt), AverageMonthlyPayment=mean(total_pymnt))
lcdf %>% group_by(sub_grade) %>% summarise(nLoans=n(), AverageInterestRate= mean(int_rate), SDInterest=sd(int_rate), AverageLoanAmount=mean(loan_amnt), AverageMonthlyPayment=mean(total_pymnt))
lcdf %>% group_by(grade) %>% summarise(nLoans=n(), AverageInterestRate= mean(int_rate), SDInterest=sd(int_rate), MaxInterestRate=max(int_rate), MinInterestRate=min(int_rate))
lcdf %>% group_by(sub_grade) %>% summarise(nLoans=n(), AverageInterestRate= mean(int_rate), SDInterest=sd(int_rate), MaxInterestRate=max(int_rate), MinInterestRate=min(int_rate))



```
# Q2.a.iii

```{r}
lcdf$last_pymnt_d<-paste(lcdf$last_pymnt_d, "-01", sep = "")
lcdf$last_pymnt_d<-parse_date_time(lcdf$last_pymnt_d,  "myd") #to transfer to date format
head(lcdf[, c("last_pymnt_d", "issue_d")])

lcdf$actualTerm <- ifelse(lcdf$loan_status=="Fully Paid", 
                          as.duration(lcdf$issue_d  %--% lcdf$last_pymnt_d)/dyears(1), 
                          3)
# to see varying actual term for fully paid loans
lcdf %>% group_by(loan_status="Fully Paid", actualTerm) %>% tally()
# to see the varying actual term for grade
lcdf %>% group_by(grade) %>% summarise(median(actualTerm)) # to check varying loan grade with actual term
ggplot(lcdf, aes( x = actualTerm)) + geom_histogram() + facet_wrap(~loan_status)# to check the varying actual term with loan status
# Boxplot of grades vs actual term
boxplot(actualTerm~grade,data=lcdf, main="Grades VS Actual Term",
        xlab="Grades", ylab="Actual Term")
```

# Q: 2.(iv)
Calculate the annual return. Show how you calculate the percentage annual return.
Is there any return from loans which are ‘charged off’? Explain. How does return from charged -
off loans vary by loan grade?
Compare the average return values with the average interest_rate on loans – do you notice any
differences, and how do you explain this?
How do returns vary by grade, and by sub-grade.
If you wanted to invest in loans based on this data exploration, which loans would you invest in?
```{r}
#calculate the annualized percentage return
lcdf$annRet <- ((lcdf$total_pymnt -lcdf$funded_amnt)/lcdf$funded_amnt)*(12/36)*100
#Added New Column annRet to dataset lcdf
summary(lcdf$annRet)
#summarize by grade
lcdf %>% group_by(grade) %>% summarise(nLoans=n(), defaults=sum(loan_status=="Charged Off"), avgInterest= mean(int_rate), stdInterest=sd(int_rate), avgLoanAMt=mean(loan_amnt), avgPmnt=mean(total_pymnt), avgRet=mean(annRet), stdRet=sd(annRet), minRet=min(annRet), maxRet=max(annRet))

## Is there any return from loans which are ‘charged off’?

annualRetByStatus <- lcdf%>% group_by(loan_status) %>% summarise(avgInterest=mean(int_rate), AvgAnnaulRet=mean(annRet))
annualRetByStatus

ggplot(annualRetByStatus,aes(x=loan_status,y=AvgAnnaulRet,fill = loan_status)) + geom_bar( stat = "identity", width = 0.2) +xlab("Loan Status") + ylab("Average Annual Return")

## Explain. How does return from charged - off loans vary by loan grade?


retChargedoffgrade <- lcdf %>% group_by(loan_status, grade) %>% summarise(AvgAnnaulRet=mean(annRet))
retChargedoffgrade
justretChargedoffgrade <- retChargedoffgrade %>% filter(loan_status == "Charged Off")
justretChargedoffgrade
ggplot(justretChargedoffgrade,aes(x=grade,y=AvgAnnaulRet,fill = grade)) + geom_bar( stat = "identity", width = 0.2) +xlab("Loan Grade") + ylab("Average Annual Return")


### Compare average return values with average interest rate

data1 <- lcdf%>% group_by(grade) %>% summarise(AvgintRate=mean(int_rate), AvgAnnaulRet=mean(annRet))
data2 <- lcdf%>% group_by(sub_grade) %>% summarise(AvgintRate=mean(int_rate), AvgAnnaulRet=mean(annRet))
data1
ggplot(data1, aes(x=grade, y = AvgintRate, fill = grade)) + geom_bar( stat = "identity", width = 0.2) +xlab("Loan Grade") + ylab("Average Interest Rate")
ggplot(data1, aes(x=grade, y = AvgAnnaulRet, fill = grade)) + geom_bar( stat = "identity", width = 0.2) +xlab("Loan Grade") + ylab("Average Return Rate")

lcdf %>% 
  group_by(grade) %>% 
  summarise(
    Count_of_loans=n(),
    defaultrate = ((sum(loan_status=='Charged Off')/Count_of_loans)*100)
  )


#Average Annual returns vary by grade?

AreturnBygrade <- lcdf %>%  group_by(grade) %>% summarise(AvgAnnaulRet=mean(annRet))
AreturnBygrade
mean(lcdf$annRet)

ggplot(AreturnBygrade,aes(x=grade,y=AvgAnnaulRet,fill = grade)) + geom_bar( stat = "identity", width = 0.5) +xlab("Loan Grade") + ylab("Average Annual Return")

#Average Annual returns vary by Sub grade?

AreturnBySubgrade <- lcdf %>%  group_by(sub_grade) %>% summarise(AvgAnnaulRet=mean(annRet))
AreturnBySubgrade

ggplot(AreturnBySubgrade,aes(x=sub_grade,y=AvgAnnaulRet, fill = sub_grade)) + geom_bar( stat = "identity", width = 0.5) +xlab("Loan Sub-Grade") + ylab("Average Annual Return")

```

# Q2.a.v

```{r}
lcdf %>% group_by(purpose) %>% summarise(nLoans=n(),
                                         defaults=sum(loan_status=="Charged Off"), 
                                         avgLoanAmt=mean(loan_amnt),
                                         medLoanAmt=median(loan_amnt),
                                         avgincome=mean(annual_inc),
                                         medincome=median(annual_inc))


table(lcdf$purpose, lcdf$grade)
ggplot(lcdf, aes( x = purpose)) + geom_bar() # to check varying number of loans with purpose
boxplot(lcdf$loan_amnt ~ lcdf$purpose) # to check varying loan amounts with purpose
ggplot(lcdf, aes( x = purpose)) + geom_bar(aes(fill=grade)) # to check varying grade with purpose
```

# Q2.a.vi.
```{r}
# Does default rate, int-rate, etc vary by loan purpose
lcdf %>% group_by(purpose) %>% tally()
lcdf$annInc_level <- cut(lcdf$annual_inc, breaks = c(-Inf,5000,10000,15000,20000,Inf),labels = c("<=5000",">5000&<=10000",">10000&<=15000",">15000&<=20000",">20000"))
lcdf %>% group_by(purpose,grade) %>% summarise(nLoans=n(), defaults=sum(loan_status=="Charged Off"), defaultRate=defaults/nLoans, avgIntRate=mean(int_rate),  avgLoanAmt=mean(loan_amnt),  avgActRet = mean(annRet), avgActTerm=mean(actualTerm))
lcdf %>% group_by(emp_length,grade) %>% summarise(nLoans=n(), defaults=sum(loan_status=="Charged Off"), defaultRate=defaults/nLoans, avgIntRate=mean(int_rate),  avgLoanAmt=mean(loan_amnt),  avgActRet = mean(annRet), avgActTerm=mean(actualTerm))
lcdf %>% group_by(annInc_level,grade) %>% summarise(nLoans=n(), defaults=sum(loan_status=="Charged Off"), defaultRate=defaults/nLoans, avgIntRate=mean(int_rate),  avgLoanAmt=mean(loan_amnt),  avgActRet = mean(annRet), avgActTerm=mean(actualTerm))

#Does loan-grade vary by purpose?
table(lcdf$purpose, lcdf$grade)


#some other detailed analyses
#Does loan purpose relate to emp_length?
table(lcdf$purpose, lcdf$emp_length)

#do those with home-improvement loans own or rent a home?
table(lcdf$home_ownership, lcdf$purpose)



lcdf %>% group_by(purpose) %>% tally()
#some of category levels have very few examples 
#    do you want to recode such categories with very few cases to "other"
lcdf$purpose <- fct_recode(lcdf$purpose, other="wedding", other="educational", other="renewable_energy")


#Plot of loan amount by purpose
boxplot(lcdf$loan_amnt ~ lcdf$purpose)
```

# Q2.a.vii

```{r}
# derived attribute for default prediction


#1 significant EMI - 20% of annual income - the installment * 12
lcdf$emi_sig <- (lcdf$annual_inc * 0.2) - (lcdf$installment * 12)
lcdf %>% filter(lcdf$emi_sig <  0) %>% tally()

#2 employement years greater than 10y - 
lcdf$emp_10 <- ifelse(lcdf$emp_length=="10+ years", 1, 0)
lcdf %>% filter(lcdf$emp_10 ==  1) %>% tally()

#3 till date payment of loan amount
lcdf$prop_credit_lines <- ifelse(lcdf$total_acc>0, lcdf$open_acc/lcdf$total_acc, 0)
lcdf %>% filter(lcdf$prop_credit_lines >  0.6) %>% tally()

```


# Question 2 (c) #

```{r}
###Are there missing values? What is the proportion of missing values in different variables? Explain how you will handle missing values for different variables. You should consider what the variable is about, and what missing values may arise from – for example, a variable monthsSinceLastDeliquency may have no value for someone who has not yet had a delinquency; what is a sensible value to replace the missing values in this case? Are there some variables you will exclude from your model due to missing values?
############# Missing values######################

### R code to plot NA Values
# library(visdat)
# vis_dat(lcdf, warn_large_data = FALSE)
# vis_miss(lcdf, warn_large_data = FALSE)

###Proportion of na's in different variables####

dim(lcdf)

###### Drop variables with 100% NA values

lcdf <- lcdf %>% select_if(function(x){!all(is.na(x))})
dim(lcdf)
################columns where there are missing values

colMeans(is.na(lcdf))[colMeans(is.na(lcdf))>0]
dim(lcdf)
###remove variables which have more than 60% missing values


colMeans(is.na(lcdf))>0.6

finalnona<-names(lcdf)[colMeans(is.na(lcdf))>0.6]
final_lcdf <- lcdf %>% select(-finalnona)
dim(final_lcdf)

################### columns with remaining missing values
colMeans(is.na(final_lcdf))[colMeans(is.na(final_lcdf))>0]
#summary of data in these columnsfinal_lcdf
nm<- names(final_lcdf)[colSums(is.na(final_lcdf))>0]
summary(final_lcdf[, nm])

######Replace missing values with some value###


NoNAlcdf <- final_lcdf %>% replace_na(list(mths_since_last_delinq=500, revol_util=median(final_lcdf$revol_util, na.rm=TRUE), bc_open_to_buy=median(final_lcdf$bc_open_to_buy, na.rm=TRUE), mo_sin_old_il_acct=1000, mths_since_recent_bc=1000, mths_since_recent_inq=50, num_tl_120dpd_2m = median(lcdf$num_tl_120dpd_2m, na.rm=TRUE),percent_bc_gt_75 = median(final_lcdf$percent_bc_gt_75, na.rm=TRUE), bc_util=median(final_lcdf$bc_util, na.rm=TRUE), avg_cur_bal=median(final_lcdf$avg_cur_bal,na.rm = TRUE), num_rev_accts=mean(final_lcdf$num_rev_accts,na.rm = TRUE), emp_length=median(final_lcdf$emp_length,na.rm = TRUE), pct_tl_nvr_dlq=mean(final_lcdf$pct_tl_nvr_dlq, na.rm = TRUE)))

#####To check if we have no more NA values #######

colMeans(is.na(NoNAlcdf))[colMeans(is.na(NoNAlcdf))>0]
NoNAlcdf

# Charged off loans will not have a last payment date  - so we are excluding this one and this can cause data leakage

### Above two values (last_credit_pull_d and nlast_pymnt_d )still have NA and we will exclude them from the model as they cause data leakage. 
# emp_title and title will not be used in predicting default and we have excluded that. 

```
# Q3 Question No .3 Data Leakage - Theory attached in pdf.

# Q4 #


```{r}
# ##Do a univariate analyses to determine which variables (from amongst those you decide to
# consider for the next stage prediction task) will be individually useful for predicting the
# dependent variable (loan_status). For this, you need a measure of relationship between the
# dependent variable and each of the potential predictor variables. Given loan-status as a binary
# dependent variable, which measure will you use? From your analyses using this measure,
# which variables do you think will be useful for predicting loan_status?
# (Note – if certain variables on their own are highly predictive of the outcome, it is good to ask if
# this variable has a leakage issue).
# ##
#univariate test
library(pROC) #this package has a function auc(..) which we can readily use

#Considering both numeric and factor variables:
aucAll<- sapply(lcdf %>% mutate_if(is.factor, as.numeric) %>% select_if(is.numeric), auc, response=lcdf$loan_status) 
#aucAll<- sapply(lcdf %>% mutate_if(is.factor, as.numeric) %>% select_if(is.numeric), pROC::auc, response=lcdf$loan_status)

#TO determine which variables have auc > 0.5
aucAll[aucAll>0.5]

#Or, we can use the tidy(..) function from the broom package - which converts the 'messy' output into a tidy form as a tibble
library(broom)

tidy(aucAll[aucAll > 0.5]) %>% view()  #(to see the ones which have values below 0.5 )

# or  in any range of values like, tidy(aucAll[aucAll >=0.5 & aucAll < 0.6])
# or in sorted order
aucVar <- tidy(aucAll[aucAll > 0.5]) %>% arrange(desc(aucAll[aucAll > 0.5]))
ggplot(aucVar, aes(y=reorder(names, -x), x = x )) + geom_bar( stat = "identity") +xlab("aucValue") + ylab("Variable")

    


```
# Including only the selected variables from the given data sample of the Lending Club Data 
```{r}

varsOmit <- c('actualTerm', 'issue_d','last_pymnt_d',
'zip_code',
'emp_title',
'last_credit_pull_d',
'pymnt_plan',
'addr_state',
'policy_code',
'disbursement_method',
'title',
'term',
'funded_amnt_inv',
'out_prncp',
'out_prncp_inv',
'total_pymnt_inv',
'total_rec_prncp',
'total_rec_int',
'debt_settlement_flag',
'hardship_flag',
'application_type',
'last_pymnt_amnt',
'last_pymnt_d',
'funded_amnt_inv',
'mths_since_last_delinq',
'last_pymnt_amnt',
'actualTerm',
'total_pymnt',
'issue_d',
'funded_amnt',
'last_pymnt_d',
'recoveries',
'num_tl_op_past_12m',
'collection_recovery_fee',
'total_rec_late_fee',
'num_tl_120dpd_2m',
'num_tl_30dpd',
'num_tl_90g_dpd_24m',
'annInc_level',
'annRet',
'earliest_cr_line',
'emi_sig',
'emp_10',
'prop_credit_lines',
'num_tl_op_past_12m',
'earliest_cr_line'
)  #are there others?

mydata <- NoNAlcdf %>% select(-varsOmit)


#change chr to factors:
mydata$grade <- factor(mydata$grade, levels=c("A", "B","C","D", "E","F","G"))

mydata$sub_grade <- factor(mydata$sub_grade, levels=c("A1", "A2", "A3", "A4", "A5", "B1", "B2", "B3", "B4", "B5", "C1", "C2", "C3", "C4", "C5", "D1", "D2", "D3", "D4", "D5", "E1", "E2", "E3", "E4", "E5", "F1", "F2", "F3", "F4", "F5", "G1", "G2", "G3", "G4", "G5"))

mydata$initial_list_status <- factor(mydata$initial_list_status, levels=c("w", "f"))

mydata$loan_status <- factor(mydata$loan_status, levels=c("Fully Paid", "Charged Off"))

mydata$emp_length <- factor(mydata$emp_length, levels=c("n/a", "< 1 year","1 year","2 years", "3 years" ,  "4 years",   "5 years",   "6 years",   "7 years" ,  "8 years", "9 years", "10+ years" ))

mydata$purpose <- fct_recode(mydata$purpose)

mydata$home_ownership <- as.factor((mydata$home_ownership))
mydata$verification_status<- as.factor(mydata$verification_status)
#mydata$earliest_cr_line<- as.factor(mydata$earliest_cr_line)
# str(mydata)
dim(mydata)

```


# Split Train and Test Data
```{r }
#split the data into trn, tst subsets
nr=nrow(mydata)
mydata
trnIndex = sample(1:nr, size = round(0.7*nr), replace=FALSE)
lcdfTrn=mydata[trnIndex,]
lcdfTst = mydata[-trnIndex,]

dim(lcdfTrn)
dim(lcdfTst)

 str(lcdfTrn)
```

# DT models using C50
```{r}
library(C50)
#split the data into training and test(validation) sets - 70% for training, rest for validation
glimpse(lcdfTrn)

set.seed(123)
#Are are some variable you want to exclude  - due to leakage, or other reasons?
#  What about variables like actualTerm, actualReturn which you calculated?
#       These will be useful in performance assessment, but should not be used in building the model.
#Are there any data variables which you may not want to use in developing the model?



#It can be useful to convert the target variable, loan_status to  a factor variable
lcdfTrn$loan_status <- factor(lcdfTrn$loan_status, levels=c("Fully Paid", "Charged Off"))

#C50model <- C5.0(loan_status ~., data=lcdfTrn %>% select(-varsOmit),parms = list(split = "information"), control = C5.0Control(minCases=10))

#print(lcDT1)  #reasonable ?

#variable importance
  # Does this look reasonable?  Any leakage causing variables can show up as highly important !
#1
C50model <- C5.0(loan_status ~., data=lcdfTrn, control = C5.0Control(CF = 0.4, minCases = 10))
print(C50model)

#2
C50model1 <- C5.0(loan_status ~., data=lcdfTrn, control = C5.0Control(CF = 0.3))
print(C50model1)

#3
C50model2 <- C5.0(loan_status ~., data=lcdfTrn, control = C5.0Control(CF = 0.4))
print(C50model2)

#4
C50model3 <- C5.0(loan_status ~., data=lcdfTrn, control = C5.0Control(minCases = 10))
print(C50model3)


#1
C5imp(C50model,metric = "usage",pct = TRUE)


```

# Performance evaluation c50
```{r}
#Evaluate performance
#1
predTrn=predict(C50model,lcdfTrn, type='class')
table(pred = predTrn, true=lcdfTrn$loan_status)
mean(predTrn == lcdfTrn$loan_status)
table(pred = predict(C50model,lcdfTst, type='class'), true=lcdfTst$loan_status)
mean(predict(C50model,lcdfTst, type='class') ==lcdfTst$loan_status)
#2
predTrn=predict(C50model1,lcdfTrn, type='class')
table(pred = predTrn, true=lcdfTrn$loan_status)
mean(predTrn == lcdfTrn$loan_status)
table(pred = predict(C50model1,lcdfTst, type='class'), true=lcdfTst$loan_status)
mean(predict(C50model1,lcdfTst, type='class') ==lcdfTst$loan_status)
#3
predTrn=predict(C50model2,lcdfTrn, type='class')
table(pred = predTrn, true=lcdfTrn$loan_status)
mean(predTrn == lcdfTrn$loan_status)
table(pred = predict(C50model2,lcdfTst, type='class'), true=lcdfTst$loan_status)
mean(predict(C50model2,lcdfTst, type='class') ==lcdfTst$loan_status)
#
predTrn=predict(C50model3,lcdfTrn, type='class')
table(pred = predTrn, true=lcdfTrn$loan_status)
mean(predTrn == lcdfTrn$loan_status)
table(pred = predict(C50model3,lcdfTst, type='class'), true=lcdfTst$loan_status)
mean(predict(C50model3,lcdfTst, type='class') ==lcdfTst$loan_status)
#With a different classsification threshold

CTHRESH=0.3
predProbTrn=predict(C50model1,lcdfTrn, type='prob')
predTrnCT = ifelse(predProbTrn[, 'Charged Off'] > CTHRESH, 'Charged Off', 'Fully Paid')
table(predTrnCT , true=lcdfTrn$loan_status)
# Or, to set the predTrnCT values as factors, and then get the confusion matrix
table(predictions=factor(predTrnCT, levels=c("Fully Paid", "Charged Off")), actuals=lcdfTrn$loan_status)

predTst=predict(C50model,lcdfTst, type='class')
predTst1=predict(C50model1,lcdfTst, type='class')
predTst2=predict(C50model2,lcdfTst, type='class')
predTst3=predict(C50model3,lcdfTst, type='class')


#Or you can use the confusionMatrix fuction from the caret package
library(caret)
confusionMatrix(predTrn, lcdfTrn$loan_status)
    #if you get an error saying that the 'e1071' package is required, 
    # you should install and load that too
#Notice that the output says 
#   'Positive' class: Fully Paid
#So,the confusionMatrix based performance measures are based 
#  on the "Fully Paid" class as the class of interest.
# If you want to get performance measure for "Charged Off", use 
#    the positive- paremeter
confusionMatrix(predTrn, lcdfTrn$loan_status, positive="Charged Off")
confusionMatrix(predTst, lcdfTst$loan_status, positive="Charged Off")


confusionMatrix(predTst1, lcdfTst$loan_status, positive="Charged Off")


confusionMatrix(predTst2, lcdfTst$loan_status, positive="Charged Off")


confusionMatrix(predTst3, lcdfTst$loan_status, positive="Charged Off")

#ROC plot
library(ROCR)

score=predict(C50model1,lcdfTst, type="prob")[,"Charged Off"]
pred=prediction(score, lcdfTst$loan_status, label.ordering = c("Fully Paid", "Charged Off"))
    #label.ordering here specifies the 'negative', 'positive' class labels   

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values


#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)


```
# DT models using rpart
```{r}

#Do you want to use all the variables in the dataset as predictors ?
#Take a look at teh data
#glimpse(lcdf)

#Are are some variable you want to exclude  - due to leakage, or other reasons?
#  What about variables like actualTerm, actualReturn which you calculated?
#       These will be useful in performance assessment, but should not be used in building the model.
#Are there any data variables which you may not want to use in developing the model?


  #are there others?
#varsomit <- c('annRet', 'chargeoff_within_12_mths')
#lcdf1 <- lcdf1 %>% select(-varsomit)
# glimpse(lcdf1)
library(rpart)
set.seed(12345)


lcDT1 <- rpart(loan_status ~., data=lcdfTrn, method="class", parms = list(split = "information"), control = rpart.control(minsplit = 30))
printcp(lcDT1)  #reasonable ?

#variable importance
lcDT1$variable.importance
  # Does this look reasonable?  Any leakage causing variables can show up as highly important !


lcDT1 <- rpart(loan_status ~., data=lcdfTrn, method="class", parms = list(split = "information"), control = rpart.control(cp=0.0003, minsplit = 50))

#Do we want to prune the tree -- check for performance with different cp levels
printcp(lcDT1)
lcDT1p<- prune.rpart(lcDT1, cp= 3.0953e-04)

#......

```


# Performance evaluation rpart
```{r}
#Evaluate performance
predTrn=predict(lcDT1,lcdfTrn, type='class')
table(pred = predTrn, true=lcdfTrn$loan_status)
mean(predTrn == lcdfTrn$loan_status)
table(pred = predict(lcDT1,lcdfTst, type='class'), true=lcdfTst$loan_status)
mean(predict(C50model3,lcdfTst, type='class') ==lcdfTst$loan_status)


CTHRESH=0.3
predProbTrn=predict(lcDT1,lcdfTrn, type='prob')
predTrnCT = ifelse(predProbTrn[, 'Charged Off'] > CTHRESH, 'Charged Off', 'Fully Paid')
table(predTrnCT , true=lcdfTrn$loan_status)
# Or, to set the predTrnCT values as factors, and then get the confusion matrix
table(predictions=factor(predTrnCT, levels=c("Fully Paid", "Charged Off")), actuals=lcdfTrn$loan_status)


predTst=predict(lcDT1, lcdfTst, type='class')
predProbTst=predict(lcDT1,lcdfTst, type='prob')
predTstCT = ifelse(predProbTst[, 'Charged Off'] > CTHRESH, 'Charged Off', 'Fully Paid')
table(predTstCT , true=lcdfTst$loan_status)
# Or, to set the predTrnCT values as factors, and then get the confusion matrix
table(predictions=factor(predTstCT, levels=c("Fully Paid", "Charged Off")), actuals=lcdfTst$loan_status)





#Or you can use the confusionMatrix fuction from the caret package
library(caret)

#Confusion Matrix for Training data
confusionMatrix(predTrn, lcdfTrn$loan_status, positive="Charged Off")


#Confusion Matrix for Test data
confusionMatrix(predTst, lcdfTst$loan_status, positive="Charged Off")

#ROC plot
library(ROCR)

score=predict(lcDT1,lcdfTst, type="prob")[,"Charged Off"]
pred=prediction(score, lcdfTst$loan_status, label.ordering = c("Fully Paid", "Charged Off"))
    #label.ordering here specifies the 'negative', 'positive' class labels   

#ROC curve
aucPerf <-performance(pred, "tpr", "fpr")
plot(aucPerf)
abline(a=0, b= 1)

#AUC value
aucPerf=performance(pred, "auc")
aucPerf@y.values


#Lift curve
liftPerf <-performance(pred, "lift", "rpp")
plot(liftPerf)

```

Question 6 - Random Forest Model 1 with 50 trees

```{r}
PROFITVAL <- 24
COSTVAL <- -35
#Performance
scoreTstRF <- predict(C50model, lcdfTst, type="prob")[,"Fully Paid"]
prPerfRF <- data.frame(scoreTstRF)
prPerfRF <- cbind(prPerfRF, status=lcdfTst$loan_status)
prPerfRF <- prPerfRF[order(-scoreTstRF) ,] #sort in desc order of prob(fully_paid)
prPerfRF$profit <- ifelse(prPerfRF$status == 'Fully Paid', PROFITVAL, COSTVAL)
prPerfRF$cumProfit <- cumsum(prPerfRF$profit)
max(prPerfRF$cumProfit)
prPerfRF$cumProfit[which.max(prPerfRF$cumProfit)]
```                   